{{ define "main" }}
<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">{{ .Title }}</h1>
  </header>
  
  <div class="post-content">
    {{ .Content }}
    <div class="graph-wrapper" style="position: relative;">
      <div id="graph-container" style="width: 100%; height: 500px; background: var(--theme); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden;"></div>
      <button id="fullscreen-btn" style="position: absolute; top: 10px; right: 10px; padding: 5px; background: var(--theme); border: 1px solid var(--border); border-radius: var(--radius); cursor: pointer; z-index: 2;">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
      </button>
    </div>
  </div>
</article>

<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/force-graph"></script>
<script>
document.addEventListener('DOMContentLoaded', () => {
  const container = document.getElementById('graph-container');
  const fullscreenBtn = document.getElementById('fullscreen-btn');
  const NODE_SIZE = 4;
  const PADDING = 10;
  
  const NODE_COLORS = {
    til: '#58a6ff',
    portfolio: '#7ee787',
    random: '#ff7b72',
    default: '#1f6feb',
    highlight: '#ff6b6b'
  };
  
  const getBoundingBox = nodes => {
    if (!nodes.length) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
    
    return nodes.reduce((box, node) => {
      const x = node.x || 0;
      const y = node.y || 0;
      box.minX = x < box.minX ? x : box.minX;
      box.maxX = x > box.maxX ? x : box.maxX;
      box.minY = y < box.minY ? y : box.minY;
      box.maxY = y > box.maxY ? y : box.maxY;
      return box;
    }, { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
  };

  const calculateGridPositions = (nodes, width, height) => {
    const count = nodes.length;
    const gridSize = Math.ceil(Math.sqrt(count));
    const xStep = width / (gridSize + 1);
    const yStep = height / (gridSize + 1);
    
    for (let i = 0; i < count; i++) {
      const row = Math.floor(i / gridSize);
      const col = i % gridSize;
      nodes[i].x = (col + 0.5) * xStep + (Math.random() * 10 - 5); // Add small jitter for natural look
      nodes[i].y = (row + 0.5) * yStep + (Math.random() * 10 - 5);
      nodes[i]._color = NODE_COLORS[nodes[i].section] || NODE_COLORS.default;
    }
  };

  const fitNodes = (graph, duration = 250) => {
    const { nodes } = graph.graphData();
    if (!nodes.length) return;
    
    const width = container.clientWidth;
    const height = container.clientHeight;
    const box = getBoundingBox(nodes);
    
    const graphWidth = box.maxX - box.minX + NODE_SIZE * 2;
    const graphHeight = box.maxY - box.minY + NODE_SIZE * 2;
    
    const scale = Math.min(
      (width - PADDING * 2) / graphWidth,
      (height - PADDING * 2) / graphHeight
    ) * 0.95;
    
    const centerX = (box.minX + box.maxX) / 2;
    const centerY = (box.minY + box.maxY) / 2;
    
    requestAnimationFrame(() => {
      graph.centerAt(centerX, centerY, duration);
      graph.zoom(scale, duration);
    });
  };

  const initializeGraph = () => {
    let graph = null;
    let hoveredNode = null;
    let isFullscreen = false;
    
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 3000);
    
    fetch('{{ "graph/index.json" | relURL }}', { signal: controller.signal })
      .then(res => {
        clearTimeout(timeoutId);
        if (!res.ok) throw new Error(`Network error: ${res.status}`);
        return res.json();
      })
      .then(data => {
        if (!data.nodes?.length) {
          container.innerHTML = '<div style="display:flex;justify-content:center;align-items:center;height:100%;">No graph data available</div>';
          return;
        }
        
        const width = container.clientWidth;
        const height = container.clientHeight;
        
        calculateGridPositions(data.nodes, width, height);
        
        graph = ForceGraph()(container)
          .graphData(data)
          .nodeId('id')
          .nodeLabel(node => {
            if (!node._label) {
              const parts = [];
              if (node.name) parts.push(node.name);
              if (node.tags?.length) parts.push(`Tags: ${node.tags.join(', ')}`);
              if (node.categories?.length) parts.push(`Categories: ${node.categories.join(', ')}`);
              node._label = parts.join('\n');
            }
            return node._label;
          })
          .nodeVal(NODE_SIZE)
          .nodeColor(node => node._color)
          .linkColor('#8b949e')
          .nodeRelSize(4)
          .linkWidth(link => Math.sqrt(link.value) * 0.4)
          .linkDirectionalParticles(0)
          .maxZoom(20)
          .minZoom(0.01)
          .enableNodeDrag(true)
          .enableZoomInteraction(true);
        
        graph
          .d3Force('link', d3.forceLink()
            .id(d => d.id)
            .distance(60)
            .strength(0.5)
          )
          .d3Force('charge', d3.forceManyBody()
            .strength(-40)
            .theta(0.8) // Barnes-Hut approximation - O(n log n) instead of O(nÂ²)
            .distanceMax(150)
          )
          .d3Force('center', d3.forceCenter(width / 2, height / 2))
          .d3Force('collision', d3.forceCollide(NODE_SIZE * 1.2))
          .d3AlphaDecay(0.05) 
          .d3VelocityDecay(0.4) 
          .cooldownTicks(50) 
          .warmupTicks(20); 
        
        graph.onNodeHover(node => {
          if (node === hoveredNode) return; // Skip if same node
          
          if (hoveredNode) {
            hoveredNode._color = NODE_COLORS[hoveredNode.section] || NODE_COLORS.default;
          }
          
          hoveredNode = node;
          if (node) {
            node._color = NODE_COLORS.highlight;
          }
        });
        
        graph.onNodeClick(node => {
          if (node?.id) window.location.href = node.id;
        });
        
        fitNodes(graph, 0);
        
        let hasStabilized = false;
        graph.onEngineStop(() => {
          if (!hasStabilized) {
            fitNodes(graph, 300);
            hasStabilized = true;
          }
        });
        
        fullscreenBtn.addEventListener('click', () => {
          isFullscreen = !isFullscreen;
          
          if (isFullscreen) {
            const styles = {
              transition: 'all 250ms ease-in-out',
              position: 'fixed',
              top: '5%',
              left: '5%',
              width: '90%',
              height: '90%',
              zIndex: '999'
            };
            
            Object.assign(container.style, styles);
            
            const overlay = document.createElement('div');
            overlay.id = 'graph-overlay';
            Object.assign(overlay.style, {
              position: 'fixed',
              top: '0',
              left: '0',
              width: '100%',
              height: '100%',
              backgroundColor: 'rgba(0,0,0,0)',
              transition: 'background-color 250ms ease-in-out',
              zIndex: '998'
            });
            
            document.body.appendChild(overlay);
            
            requestAnimationFrame(() => {
              overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
            });
            
            Object.assign(fullscreenBtn.style, {
              position: 'fixed',
              top: '6%',
              right: '6%',
              zIndex: '1000'
            });
            fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 15 6 6m-6-6v4.8m0-4.8h4.8M9 19.8V15m0 0H4.2M9 15l-6 6M15 4.2V9m0 0h4.8M15 9l6-6M9 4.2V9m0 0H4.2M9 9 3 3"/></svg>`;
          } else {
            const styles = {
              position: 'relative',
              top: '',
              left: '',
              width: '100%',
              height: '500px',
              zIndex: ''
            };
            
            Object.assign(container.style, styles);
            
            const overlay = document.getElementById('graph-overlay');
            if (overlay) {
              overlay.style.backgroundColor = 'rgba(0,0,0,0)';
              setTimeout(() => overlay.remove(), 250);
            }
            
            Object.assign(fullscreenBtn.style, {
              position: 'absolute',
              top: '10px',
              right: '10px',
              zIndex: '2'
            });
            fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>`;
          }
          
          setTimeout(() => {
            if (graph) {
              requestAnimationFrame(() => {
                graph.width(container.clientWidth);
                graph.height(container.clientHeight);
                graph.d3Force('center', d3.forceCenter(container.clientWidth / 2, container.clientHeight / 2));
                fitNodes(graph, 250);
              });
            }
          }, 260);
        });
        
        let resizeRAF;
        window.addEventListener('resize', () => {
          if (resizeRAF) cancelAnimationFrame(resizeRAF);
          
          resizeRAF = requestAnimationFrame(() => {
            if (graph) {
              graph.width(container.clientWidth);
              graph.height(container.clientHeight);
              graph.d3Force('center', d3.forceCenter(container.clientWidth / 2, container.clientHeight / 2));
              fitNodes(graph, 250);
            }
          });
        });
      })
      .catch(error => {
        clearTimeout(timeoutId);
        console.error('Error loading graph data:', error);
        container.innerHTML = `<div style="display:flex;justify-content:center;align-items:center;height:100%;">Error loading graph: ${error.name === 'AbortError' ? 'Request timed out' : error.message}</div>`;
      });
  };
  
  initializeGraph();
});
</script>
{{ end }}