{{ define "main" }}
<article class="post-single">
  <header class="post-header">
    <h1 class="post-title">{{ .Title }}</h1>
  </header>
  
  <div class="post-content">
    {{ .Content }}
    <div class="graph-wrapper" style="position: relative;">
      <div id="graph-container" style="width: 100%; height: 500px; background: var(--theme); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden;"></div>
      <button id="fullscreen-btn" style="position: absolute; top: 10px; right: 10px; padding: 5px; background: var(--theme); border: 1px solid var(--border); border-radius: var(--radius); cursor: pointer; z-index: 2;">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
        </svg>
      </button>
    </div>
  </div>
</article>

<script src="https://unpkg.com/d3@7"></script>
<script src="https://unpkg.com/force-graph"></script>
<script>
(() => {
  // Constants - defined outside for better performance and memory usage
  const NODE_COLORS = Object.freeze({
    til: '#58a6ff',
    portfolio: '#7ee787',
    random: '#ff7b72',
    default: '#1f6feb',
    highlight: '#ff6b6b'
  });
  
  const LINK_STYLES = Object.freeze({
    DEFAULT_COLOR: '#8b949e',
    HIGHLIGHT_COLOR: '#c9d1d9',
    DEFAULT_WIDTH: 1.5,
    HIGHLIGHT_WIDTH: 2.5,
    PARTICLE_SIZE: 4,
    PARTICLE_SPEED: 0.01,
    PARTICLE_TRAIN_LENGTH: 4,
    PARTICLE_DROP_RATE: 0.7
  });
  
  const CONSTANTS = Object.freeze({
    NODE_SIZE: 4,
    PADDING: 10,
    FETCH_TIMEOUT: 3000,
    LINK_DISTANCE: 60,
    LINK_STRENGTH: 0.5,
    CHARGE_STRENGTH: -40,
    CHARGE_THETA: 0.8,
    CHARGE_MAX_DISTANCE: 150,
    COLLISION_RADIUS: 4.8, // NODE_SIZE * 1.2
    ALPHA_DECAY: 0.028,    // Optimized for faster stabilization
    VELOCITY_DECAY: 0.4,
    COOLDOWN_TICKS: 30,    // Reduced from 50
    WARMUP_TICKS: 10,      // Reduced from 20
    TRANSITION_DURATION: 250,
    FIT_SCALE_FACTOR: 0.95,
    WORKER_BATCH_SIZE: 500
  });
  
  // Use performance.now() for more accurate timing
  const getTime = typeof performance !== 'undefined' ? performance.now.bind(performance) : Date.now;
  
  // Reusable weak map for caching calculations
  const calculationCache = new WeakMap();
  
  class GraphVisualizer {
    constructor(container, fullscreenBtn) {
      this.container = container;
      this.fullscreenBtn = fullscreenBtn;
      this.graph = null;
      this.hoveredNode = null;
      this.highlightedLinks = new Set();
      this.highlightedNodes = new Set();
      this.isFullscreen = false;
      this.hasStabilized = false;
      this.dataLoadStartTime = 0;
      this.resizeRAF = null;
      this.abortController = new AbortController();
      this.isRendering = false;
      this.tickCount = 0;
      
      // Pre-bind methods to avoid creating new function objects
      this.handleResize = this.handleResize.bind(this);
      this.handleFullscreenToggle = this.handleFullscreenToggle.bind(this);
      this.handleNodeHover = this.handleNodeHover.bind(this);
      this.handleNodeClick = this.handleNodeClick.bind(this);
      this.handleEngineStop = this.handleEngineStop.bind(this);
      this.handleLinkHover = this.handleLinkHover.bind(this);
      
      this.initEventListeners();
    }
    
    initEventListeners() {
      window.addEventListener('resize', this.handleResize, { passive: true });
      this.fullscreenBtn.addEventListener('click', this.handleFullscreenToggle);
    }
    
    cleanup() {
      window.removeEventListener('resize', this.handleResize);
      this.fullscreenBtn.removeEventListener('click', this.handleFullscreenToggle);
      this.abortController.abort();
      if (this.graph) {
        this.graph._destructor();
      }
    }
    
    async initialize() {
      try {
        this.dataLoadStartTime = getTime();
        const data = await this.fetchGraphData();
        
        if (!data || !data.nodes?.length) {
          this.showError('No graph data available');
          return;
        }
        
        // Preprocess links to ensure proper attributes for visualization
        this.prepareLinksForVisualization(data);
        
        // Initialize node positions with a more efficient algorithm
        this.assignInitialPositions(data.nodes);
        
        // Create the graph with optimized settings
        this.createForceGraph(data);
        
        // Start with optimal view
        requestAnimationFrame(() => this.fitGraph(0));
      } catch (error) {
        const errorMessage = error.name === 'AbortError' 
          ? 'Request timed out' 
          : error.message;
        this.showError(`Error loading graph: ${errorMessage}`);
        console.error('Graph initialization error:', error);
      }
    }
    
    prepareLinksForVisualization(data) {
      if (!data.links || !Array.isArray(data.links)) {
        data.links = [];
        return;
      }
      
      data.links.forEach(link => {
        // Ensure link value exists for width calculations
        if (typeof link.value === 'undefined' || link.value === null) {
          link.value = 1;
        }
        
        // Pre-calculate link color and width for efficient access
        link._defaultColor = LINK_STYLES.DEFAULT_COLOR;
        link._highlightColor = LINK_STYLES.HIGHLIGHT_COLOR;
        link._defaultWidth = Math.sqrt(link.value) * 0.4 + LINK_STYLES.DEFAULT_WIDTH;
        link._highlightWidth = Math.sqrt(link.value) * 0.6 + LINK_STYLES.HIGHLIGHT_WIDTH;
        link._isHighlighted = false;
      });
    }
    
    async fetchGraphData() {
      const timeoutId = setTimeout(() => this.abortController.abort(), CONSTANTS.FETCH_TIMEOUT);
      
      try {
        const response = await fetch('{{ "graph/index.json" | relURL }}', { 
          signal: this.abortController.signal,
          headers: { 'Accept': 'application/json' }
        });
        
        if (!response.ok) {
          throw new Error(`Network error: ${response.status}`);
        }
        
        return await response.json();
      } finally {
        clearTimeout(timeoutId);
      }
    }
    
    assignInitialPositions(nodes) {
      const width = this.container.clientWidth;
      const height = this.container.clientHeight;
      const count = nodes.length;
      
      // Use Fibonacci spiral layout for better initial distribution
      // More natural than grid layout and better for force layout startup
      const goldenRatio = (1 + Math.sqrt(5)) / 2;
      const angleIncrement = Math.PI * 2 / goldenRatio;
      
      const scale = Math.min(width, height) / 2 * 0.9;
      
      for (let i = 0; i < count; i++) {
        const node = nodes[i];
        const radius = Math.sqrt(i / count) * scale;
        const angle = i * angleIncrement;
        
        node.x = width / 2 + radius * Math.cos(angle);
        node.y = height / 2 + radius * Math.sin(angle);
        node._color = NODE_COLORS[node.section] || NODE_COLORS.default;
        node._isHighlighted = false;
        
        // Precompute label for performance
        if (node.name || node.tags?.length || node.categories?.length) {
          const parts = [];
          if (node.name) parts.push(node.name);
          if (node.tags?.length) parts.push(`Tags: ${node.tags.join(', ')}`);
          if (node.categories?.length) parts.push(`Categories: ${node.categories.join(', ')}`);
          node._label = parts.join('\n');
        } else {
          node._label = node.id || '';
        }
      }
    }
    
    createForceGraph(data) {
      const width = this.container.clientWidth;
      const height = this.container.clientHeight;
      
      // Create graph with optimized settings
      this.graph = ForceGraph()(this.container)
        .graphData(data)
        .nodeId('id')
        // Use cached labels for better performance
        .nodeLabel(node => node._label)
        .nodeVal(CONSTANTS.NODE_SIZE)
        .nodeColor(node => node._isHighlighted ? NODE_COLORS.highlight : node._color)
        .linkColor(link => link._isHighlighted ? link._highlightColor : link._defaultColor)
        .linkWidth(link => link._isHighlighted ? link._highlightWidth : link._defaultWidth)
        .linkDirectionalArrowLength(3)
        .linkDirectionalArrowRelPos(1)
        .linkCurvature(0)
        .linkDirectionalParticles(link => link._isHighlighted ? LINK_STYLES.PARTICLE_TRAIN_LENGTH : 0)
        .linkDirectionalParticleWidth(link => Math.min(link._highlightWidth, LINK_STYLES.PARTICLE_SIZE))
        .linkDirectionalParticleSpeed(LINK_STYLES.PARTICLE_SPEED)
        .nodeRelSize(4)
        .maxZoom(20)
        .minZoom(0.01)
        .enableNodeDrag(true)
        .enableZoomInteraction(true)
        .d3AlphaDecay(CONSTANTS.ALPHA_DECAY)
        .d3VelocityDecay(CONSTANTS.VELOCITY_DECAY)
        .cooldownTicks(CONSTANTS.COOLDOWN_TICKS)
        .warmupTicks(CONSTANTS.WARMUP_TICKS);
      
      // Set up optimized D3 force simulation
      this.graph
        .d3Force('link', d3.forceLink()
          .id(d => d.id)
          .distance(CONSTANTS.LINK_DISTANCE)
          .strength(CONSTANTS.LINK_STRENGTH)
        )
        .d3Force('charge', d3.forceManyBody()
          .strength(CONSTANTS.CHARGE_STRENGTH)
          .theta(CONSTANTS.CHARGE_THETA)
          .distanceMax(CONSTANTS.CHARGE_MAX_DISTANCE)
        )
        .d3Force('center', d3.forceCenter(width / 2, height / 2))
        .d3Force('collision', d3.forceCollide(CONSTANTS.COLLISION_RADIUS));
      
      // Set up interaction handlers
      this.graph
        .onNodeHover(this.handleNodeHover)
        .onNodeClick(this.handleNodeClick)
        .onLinkHover(this.handleLinkHover)
        .onEngineStop(this.handleEngineStop);
        
      // Optimize tick execution to avoid excessive rendering
      const originalTickFn = this.graph.tick;
      this.graph.tick = () => {
        this.tickCount++;
        
        // Only render on certain frames to improve performance
        if (this.hasStabilized || this.tickCount % 2 === 0) {
          return originalTickFn();
        }
        
        // Just advance the simulation without rendering
        const forceSimulation = this.graph.forceEngine();
        if (forceSimulation && forceSimulation.tick) {
          forceSimulation.tick();
          return this.graph;
        }
        
        return originalTickFn();
      };
    }
    
    handleLinkHover(link) {
      if (!link && this.highlightedLinks.size === 0) {
        return; // No change needed
      }
      
      const { links } = this.graph.graphData();
      
      // Reset previously highlighted links
      for (const highlightedLink of this.highlightedLinks) {
        highlightedLink._isHighlighted = false;
      }
      this.highlightedLinks.clear();
      
      // Set new highlight state
      if (link) {
        link._isHighlighted = true;
        this.highlightedLinks.add(link);
      }
      
      // Refresh the rendering for link-related attributes only
      // This avoids a full re-render and is more efficient
      if (this.graph) {
        // Re-evaluate the attributes that might have changed
        this.graph
          .linkColor(l => l._isHighlighted ? l._highlightColor : l._defaultColor)
          .linkWidth(l => l._isHighlighted ? l._highlightWidth : l._defaultWidth)
          .linkDirectionalParticles(l => l._isHighlighted ? LINK_STYLES.PARTICLE_TRAIN_LENGTH : 0);
      }
    }
    
    calculateBoundingBox(nodes) {
      if (!nodes || !nodes.length) {
        return { minX: 0, maxX: 0, minY: 0, maxY: 0 };
      }
      
      // Use reduce for a single pass through the data
      return nodes.reduce((box, node) => {
        if (!node) return box;
        
        const x = node.x || 0;
        const y = node.y || 0;
        
        box.minX = Math.min(box.minX, x);
        box.maxX = Math.max(box.maxX, x);
        box.minY = Math.min(box.minY, y);
        box.maxY = Math.max(box.maxY, y);
        
        return box;
      }, { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
    }
    
    fitGraph(duration = CONSTANTS.TRANSITION_DURATION) {
      if (!this.graph || this.isRendering) return;
      
      this.isRendering = true;
      const { nodes } = this.graph.graphData();
      
      if (!nodes || !nodes.length) {
        this.isRendering = false;
        return;
      }
      
      const width = this.container.clientWidth;
      const height = this.container.clientHeight;
      
      // Check if we have cached bounding box to avoid recalculation
      let box;
      const nodeCache = calculationCache.get(nodes);
      
      if (nodeCache && nodeCache.box && !nodeCache.dirty) {
        box = nodeCache.box;
      } else {
        box = this.calculateBoundingBox(nodes);
        calculationCache.set(nodes, { box, dirty: false });
      }
      
      const graphWidth = box.maxX - box.minX + CONSTANTS.NODE_SIZE * 2;
      const graphHeight = box.maxY - box.minY + CONSTANTS.NODE_SIZE * 2;
      
      if (graphWidth <= 0 || graphHeight <= 0) {
        this.isRendering = false;
        return;
      }
      
      const scale = Math.min(
        (width - CONSTANTS.PADDING * 2) / graphWidth,
        (height - CONSTANTS.PADDING * 2) / graphHeight
      ) * CONSTANTS.FIT_SCALE_FACTOR;
      
      const centerX = (box.minX + box.maxX) / 2;
      const centerY = (box.minY + box.maxY) / 2;
      
      // Use a single animation frame for both operations
      requestAnimationFrame(() => {
        this.graph.centerAt(centerX, centerY, duration);
        this.graph.zoom(scale, duration);
        
        // Reset rendering flag after transition completes
        setTimeout(() => {
          this.isRendering = false;
        }, duration + 50);
      });
    }
    
    findConnectedLinks(nodeId) {
      if (!nodeId) return [];
      
      const { links } = this.graph.graphData();
      return links.filter(link => 
        link.source.id === nodeId || link.source === nodeId || 
        link.target.id === nodeId || link.target === nodeId
      );
    }
    
    findConnectedNodes(nodeId) {
      if (!nodeId) return new Set();
      
      const connectedLinks = this.findConnectedLinks(nodeId);
      const connectedNodes = new Set();
      
      connectedLinks.forEach(link => {
        const sourceId = link.source.id || link.source;
        const targetId = link.target.id || link.target;
        
        if (sourceId !== nodeId) connectedNodes.add(sourceId);
        if (targetId !== nodeId) connectedNodes.add(targetId);
      });
      
      return connectedNodes;
    }
    
    handleNodeHover(node) {
      if (node === this.hoveredNode) return;
      
      const { nodes, links } = this.graph.graphData();
      
      // Reset all nodes and links first
      for (const highlightedNode of this.highlightedNodes) {
        const n = nodes.find(n => n.id === highlightedNode);
        if (n) n._isHighlighted = false;
      }
      this.highlightedNodes.clear();
      
      for (const highlightedLink of this.highlightedLinks) {
        highlightedLink._isHighlighted = false;
      }
      this.highlightedLinks.clear();
      
      this.hoveredNode = node;
      
      if (node) {
        // Highlight the hovered node
        node._isHighlighted = true;
        this.highlightedNodes.add(node.id);
        
        // Find and highlight connected links and nodes
        const connectedLinks = this.findConnectedLinks(node.id);
        for (const link of connectedLinks) {
          link._isHighlighted = true;
          this.highlightedLinks.add(link);
          
          // Highlight connected nodes too
          const sourceId = link.source.id || link.source;
          const targetId = link.target.id || link.target;
          
          const sourceNode = nodes.find(n => n.id === sourceId);
          const targetNode = nodes.find(n => n.id === targetId);
          
          if (sourceNode && sourceNode !== node) {
            sourceNode._isHighlighted = true;
            this.highlightedNodes.add(sourceId);
          }
          
          if (targetNode && targetNode !== node) {
            targetNode._isHighlighted = true;
            this.highlightedNodes.add(targetId);
          }
        }
      }
      
      // Refresh the graph with highlighting changes
      this.graph
        .nodeColor(n => n._isHighlighted ? NODE_COLORS.highlight : n._color)
        .linkColor(l => l._isHighlighted ? l._highlightColor : l._defaultColor)
        .linkWidth(l => l._isHighlighted ? l._highlightWidth : l._defaultWidth)
        .linkDirectionalParticles(l => l._isHighlighted ? LINK_STYLES.PARTICLE_TRAIN_LENGTH : 0);
    }
    
    handleNodeClick(node) {
      if (node?.id) {
        window.location.href = node.id;
      }
    }
    
    handleEngineStop() {
      if (!this.hasStabilized) {
        this.fitGraph(CONSTANTS.TRANSITION_DURATION);
        this.hasStabilized = true;
      }
    }
    
    handleResize() {
      if (this.resizeRAF) {
        cancelAnimationFrame(this.resizeRAF);
      }
      
      this.resizeRAF = requestAnimationFrame(() => {
        if (!this.graph) return;
        
        const width = this.container.clientWidth;
        const height = this.container.clientHeight;
        
        this.graph.width(width);
        this.graph.height(height);
        this.graph.d3Force('center', d3.forceCenter(width / 2, height / 2));
        
        // Mark the node cache as dirty since positions may shift
        const { nodes } = this.graph.graphData();
        if (nodes && calculationCache.has(nodes)) {
          const cache = calculationCache.get(nodes);
          cache.dirty = true;
        }
        
        this.fitGraph(CONSTANTS.TRANSITION_DURATION);
      });
    }
    
    handleFullscreenToggle() {
      this.isFullscreen = !this.isFullscreen;
      
      const container = this.container;
      const styles = {};
      
      if (this.isFullscreen) {
        styles.transition = 'all 250ms ease-in-out';
        styles.position = 'fixed';
        styles.top = '5%';
        styles.left = '5%';
        styles.width = '90%';
        styles.height = '90%';
        styles.zIndex = '999';
        
        Object.assign(container.style, styles);
        
        const overlay = document.createElement('div');
        overlay.id = 'graph-overlay';
        Object.assign(overlay.style, {
          position: 'fixed',
          top: '0',
          left: '0',
          width: '100%',
          height: '100%',
          backgroundColor: 'rgba(0,0,0,0)',
          transition: 'background-color 250ms ease-in-out',
          zIndex: '998'
        });
        
        document.body.appendChild(overlay);
        
        // Use RAF for smoother transition
        requestAnimationFrame(() => {
          overlay.style.backgroundColor = 'rgba(0,0,0,0.7)';
        });
        
        Object.assign(this.fullscreenBtn.style, {
          position: 'fixed',
          top: '6%',
          right: '6%',
          zIndex: '1000'
        });
        
        this.fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 15 6 6m-6-6v4.8m0-4.8h4.8M9 19.8V15m0 0H4.2M9 15l-6 6M15 4.2V9m0 0h4.8M15 9l6-6M9 4.2V9m0 0H4.2M9 9 3 3"/></svg>`;
      } else {
        styles.position = 'relative';
        styles.top = '';
        styles.left = '';
        styles.width = '100%';
        styles.height = '500px';
        styles.zIndex = '';
        
        Object.assign(container.style, styles);
        
        const overlay = document.getElementById('graph-overlay');
        if (overlay) {
          overlay.style.backgroundColor = 'rgba(0,0,0,0)';
          
          // Remove overlay after transition completes
          setTimeout(() => {
            if (overlay.parentNode) {
              overlay.parentNode.removeChild(overlay);
            }
          }, 250);
        }
        
        Object.assign(this.fullscreenBtn.style, {
          position: 'absolute',
          top: '10px',
          right: '10px',
          zIndex: '2'
        });
        
        this.fullscreenBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>`;
      }
      
      // Update graph dimensions after the transition
      setTimeout(() => {
        if (this.graph) {
          const width = container.clientWidth;
          const height = container.clientHeight;
          
          this.graph.width(width);
          this.graph.height(height);
          this.graph.d3Force('center', d3.forceCenter(width / 2, height / 2));
          
          // Mark cache as dirty
          const { nodes } = this.graph.graphData();
          if (nodes && calculationCache.has(nodes)) {
            const cache = calculationCache.get(nodes);
            cache.dirty = true;
          }
          
          this.fitGraph(CONSTANTS.TRANSITION_DURATION);
        }
      }, 260);
    }
    
    showError(message) {
      this.container.innerHTML = `<div style="display:flex;justify-content:center;align-items:center;height:100%;">${message}</div>`;
    }
  }
  
  // Initialize the graph when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    const container = document.getElementById('graph-container');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    
    if (!container || !fullscreenBtn) {
      console.error('Required DOM elements not found');
      return;
    }
    
    const visualizer = new GraphVisualizer(container, fullscreenBtn);
    visualizer.initialize();
    
    // Store reference for cleanup
    window.graphVisualizer = visualizer;
  });
  
  // Cleanup on page unload to prevent memory leaks
  window.addEventListener('beforeunload', () => {
    if (window.graphVisualizer) {
      window.graphVisualizer.cleanup();
      delete window.graphVisualizer;
    }
  });
})();
</script>
{{ end }}